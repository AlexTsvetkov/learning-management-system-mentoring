*** Begin Patch
*** Add File: src/main/java/com/example/project/notification/OutboxMessage.java
+package com.example.project.notification;
+
+import jakarta.persistence.*;
+import java.time.LocalDateTime;
+
+@Entity
+@Table(name = "outbox_message")
+public class OutboxMessage {
+
+    @Id
+    @GeneratedValue(strategy = GenerationType.IDENTITY)
+    private Long id;
+
+    private String recipient;
+    private String subject;
+
+    @Lob
+    private String bodyHtml;
+
+    private String failureReason;
+
+    private int attempts;
+
+    private LocalDateTime nextAttemptAt;
+
+    private boolean sent;
+
+    public OutboxMessage() {}
+
+    public OutboxMessage(String recipient, String subject, String bodyHtml, LocalDateTime nextAttemptAt) {
+        this.recipient = recipient;
+        this.subject = subject;
+        this.bodyHtml = bodyHtml;
+        this.attempts = 0;
+        this.nextAttemptAt = nextAttemptAt;
+        this.sent = false;
+    }
+
+    // getters / setters
+    public Long getId() { return id; }
+    public String getRecipient() { return recipient; }
+    public void setRecipient(String recipient) { this.recipient = recipient; }
+    public String getSubject() { return subject; }
+    public void setSubject(String subject) { this.subject = subject; }
+    public String getBodyHtml() { return bodyHtml; }
+    public void setBodyHtml(String bodyHtml) { this.bodyHtml = bodyHtml; }
+    public String getFailureReason() { return failureReason; }
+    public void setFailureReason(String failureReason) { this.failureReason = failureReason; }
+    public int getAttempts() { return attempts; }
+    public void setAttempts(int attempts) { this.attempts = attempts; }
+    public LocalDateTime getNextAttemptAt() { return nextAttemptAt; }
+    public void setNextAttemptAt(LocalDateTime nextAttemptAt) { this.nextAttemptAt = nextAttemptAt; }
+    public boolean isSent() { return sent; }
+    public void setSent(boolean sent) { this.sent = sent; }
+}
+
*** End Patch
*** Begin Patch
*** Add File: src/main/java/com/example/project/notification/OutboxRepository.java
+package com.example.project.notification;
+
+import org.springframework.data.jpa.repository.JpaRepository;
+import org.springframework.data.jpa.repository.Query;
+import org.springframework.data.repository.query.Param;
+import org.springframework.stereotype.Repository;
+
+import java.time.LocalDateTime;
+import java.util.List;
+
+@Repository
+public interface OutboxRepository extends JpaRepository<OutboxMessage, Long> {
+
+    @Query("select o from OutboxMessage o where o.sent = false and o.nextAttemptAt <= :now")
+    List<OutboxMessage> findReadyToSend(@Param("now") LocalDateTime now);
+
+}
+
*** End Patch
*** Begin Patch
*** Add File: src/main/java/com/example/project/notification/OutboxSender.java
+package com.example.project.notification;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.core.task.TaskExecutor;
+import org.springframework.mail.javamail.JavaMailSender;
+import org.springframework.mail.javamail.MimeMessageHelper;
+import org.springframework.scheduling.annotation.Scheduled;
+import org.springframework.stereotype.Component;
+import org.springframework.transaction.annotation.Transactional;
+
+import jakarta.mail.internet.MimeMessage;
+import java.time.LocalDateTime;
+import java.util.List;
+
+@Component
+public class OutboxSender {
+    private static final Logger log = LoggerFactory.getLogger(OutboxSender.class);
+
+    private final OutboxRepository outboxRepository;
+    private final JavaMailSender javaMailSender;
+    private final TaskExecutor notificationExecutor;
+
+    // configuration
+    private final int maxAttempts = 5;
+
+    public OutboxSender(OutboxRepository outboxRepository, JavaMailSender javaMailSender, TaskExecutor notificationExecutor) {
+        this.outboxRepository = outboxRepository;
+        this.javaMailSender = javaMailSender;
+        this.notificationExecutor = notificationExecutor;
+    }
+
+    // run every 2 minutes to retry pending messages
+    @Scheduled(cron = "0 */2 * * * *", zone = "Europe/Berlin")
+    @Transactional
+    public void sendPendingOutboxMessages() {
+        List<OutboxMessage> ready = outboxRepository.findReadyToSend(LocalDateTime.now());
+        if (ready == null || ready.isEmpty()) {
+            return;
+        }
+        log.info("OutboxSender: found {} message(s) ready to send", ready.size());
+
+        for (OutboxMessage m : ready) {
+            notificationExecutor.execute(() -> trySend(m));
+        }
+    }
+
+    private void trySend(OutboxMessage m) {
+        try {
+            MimeMessage msg = javaMailSender.createMimeMessage();
+            MimeMessageHelper helper = new MimeMessageHelper(msg, false, "UTF-8");
+            helper.setTo(m.getRecipient());
+            helper.setSubject(m.getSubject());
+            helper.setText(m.getBodyHtml(), true);
+            javaMailSender.send(msg);
+
+            m.setSent(true);
+            m.setFailureReason(null);
+            outboxRepository.save(m);
+            log.info("OutboxSender: successfully sent outbox message id={}", m.getId());
+        } catch (Exception ex) {
+            log.warn("OutboxSender: failed to send outbox id={} reason={}", m.getId(), ex.getMessage());
+            // increment attempts and schedule next try with exponential backoff
+            m.setAttempts(m.getAttempts() + 1);
+            m.setFailureReason(ex.getMessage());
+            if (m.getAttempts() >= maxAttempts) {
+                log.error("OutboxSender: reached max attempts for outbox id={}, marking nextAttempt far in future", m.getId());
+                m.setNextAttemptAt(LocalDateTime.now().plusYears(10));
+            } else {
+                long backoffSeconds = (long) Math.pow(2, Math.min(8, m.getAttempts())); // up to 2^8 seconds
+                m.setNextAttemptAt(LocalDateTime.now().plusSeconds(30 + backoffSeconds));
+            }
+            outboxRepository.save(m);
+        }
+    }
+}
+
*** End Patch
*** Begin Patch
*** Add File: src/main/java/com/example/project/notification/EmailService.java
+package com.example.project.notification;
+
+import com.example.project.course.model.Course;
+import com.example.project.student.model.Student;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.core.io.ClassPathResource;
+import org.springframework.mail.javamail.JavaMailSender;
+import org.springframework.mail.javamail.MimeMessageHelper;
+import org.springframework.stereotype.Service;
+import org.springframework.util.StreamUtils;
+
+import jakarta.mail.internet.MimeMessage;
+import java.nio.charset.StandardCharsets;
+import java.time.LocalDateTime;
+
+@Service
+public class EmailService {
+    private static final Logger log = LoggerFactory.getLogger(EmailService.class);
+
+    private final JavaMailSender mailSender;
+    private final OutboxRepository outboxRepository;
+
+    public EmailService(JavaMailSender mailSender, OutboxRepository outboxRepository) {
+        this.mailSender = mailSender;
+        this.outboxRepository = outboxRepository;
+    }
+
+    public void sendCourseStartingTomorrowNotification(Student student, Course course) {
+        if (student == null || student.getEmail() == null || student.getEmail().isBlank()) {
+            log.warn("Skipping email, missing student or email for student id={}", student == null ? null : student.getId());
+            return;
+        }
+
+        String subject = String.format("Reminder: course \"%s\" starts tomorrow", course.getTitle());
+
+        try {
+            String bodyHtml = renderTemplate(student, course);
+            sendHtmlEmail(student.getEmail(), subject, bodyHtml);
+            log.info("EmailService: sent email to {} for course {}", student.getEmail(), course.getId());
+        } catch (Exception ex) {
+            log.warn("EmailService: failed to send email to {} â€” persisting to outbox: {}", student.getEmail(), ex.getMessage());
+            LocalDateTime nextAttempt = LocalDateTime.now().plusSeconds(30);
+            OutboxMessage out = new OutboxMessage(student.getEmail(), subject, safeRenderTemplate(student, course), nextAttempt);
+            outboxRepository.save(out);
+        }
+    }
+
+    private void sendHtmlEmail(String to, String subject, String bodyHtml) throws Exception {
+        MimeMessage mime = mailSender.createMimeMessage();
+        MimeMessageHelper helper = new MimeMessageHelper(mime, false, "UTF-8");
+        helper.setTo(to);
+        helper.setSubject(subject);
+        helper.setText(bodyHtml, true);
+        mailSender.send(mime);
+    }
+
+    private String renderTemplate(Student student, Course course) throws Exception {
+        ClassPathResource r = new ClassPathResource("templates/course-start.html");
+        String template = StreamUtils.copyToString(r.getInputStream(), StandardCharsets.UTF_8);
+        String firstName = student.getFirstName() == null ? "" : student.getFirstName();
+        String title = course.getTitle() == null ? "" : course.getTitle();
+        String dateStr = "(unknown)";
+        if (course.getSettings() != null && course.getSettings().getStartDate() != null) {
+            dateStr = course.getSettings().getStartDate().toLocalDate().toString();
+        }
+        String desc = course.getDescription() == null ? "" : course.getDescription();
+        String out = template;
+        out = out.replace("[[FIRST_NAME]]", escapeHtml(firstName));
+        out = out.replace("[[COURSE_TITLE]]", escapeHtml(title));
+        out = out.replace("[[COURSE_DATE]]", escapeHtml(dateStr));
+        out = out.replace("[[COURSE_DESCRIPTION]]", escapeHtml(desc));
+        return out;
+    }
+
+    private String safeRenderTemplate(Student student, Course course) {
+        try {
+            return renderTemplate(student, course);
+        } catch (Exception ex) {
+            String studentName = student.getFirstName() == null ? "" : student.getFirstName();
+            String dateStr = "(unknown)";
+            if (course.getSettings() != null && course.getSettings().getStartDate() != null) {
+                dateStr = course.getSettings().getStartDate().toLocalDate().toString();
+            }
+            String desc = course.getDescription() == null ? "" : course.getDescription();
+            return "<html><body><p>Hi " + escapeHtml(studentName) + ",</p>"
+                    + "<p>This is a reminder that the course <strong>" + escapeHtml(course.getTitle()) + "</strong> starts on <strong>"
+                    + escapeHtml(dateStr) + "</strong>.</p><p>" + escapeHtml(desc) + "</p></body></html>";
+        }
+    }
+
+    private String escapeHtml(String s) {
+        if (s == null) return "";
+        return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
+                .replace("\"", "&quot;").replace("'", "&#x27;");
+    }
+}
+
*** End Patch
*** Begin Patch
*** Add File: src/main/java/com/example/project/notification/CourseNotificationScheduler.java
+package com.example.project.notification;
+
+import com.example.project.course.model.Course;
+import com.example.project.course.service.CourseService;
+import com.example.project.student.model.Student;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.beans.factory.annotation.Qualifier;
+import org.springframework.core.task.TaskExecutor;
+import org.springframework.scheduling.annotation.Scheduled;
+import org.springframework.stereotype.Component;
+
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.ZoneId;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+@Component
+public class CourseNotificationScheduler {
+
+    private static final Logger log = LoggerFactory.getLogger(CourseNotificationScheduler.class);
+
+    private final CourseService courseService;
+    private final EmailService emailService;
+    private final TaskExecutor notificationExecutor;
+
+    public CourseNotificationScheduler(CourseService courseService,
+                                       EmailService emailService,
+                                       @Qualifier("emailNotificationExecutor") TaskExecutor notificationExecutor) {
+        this.courseService = courseService;
+        this.emailService = emailService;
+        this.notificationExecutor = notificationExecutor;
+    }
+
+    /**
+     * Runs once daily at 08:00 Europe/Berlin and finds courses that start the next day.
+     * Adjust cron/zone to your needs.
+     */
+    @Scheduled(cron = "0 0 8 * * *", zone = "Europe/Berlin")
+    public void notifyCoursesStartingTomorrow() {
+        LocalDate target = LocalDate.now(ZoneId.of("Europe/Berlin")).plusDays(1);
+        LocalDateTime from = target.atStartOfDay();
+        LocalDateTime to = target.plusDays(1).atStartOfDay();
+
+        log.info("Running daily notification job for courses starting between {} and {}", from, to);
+
+        List<Course> courses = courseService.findStartingBetween(from, to);
+        if (courses == null || courses.isEmpty()) {
+            log.info("No courses starting tomorrow ({}).", target);
+            return;
+        }
+
+        log.info("Found {} course(s) starting on {}", courses.size(), target);
+
+        for (Course course : courses) {
+            List<Student> students = course.getStudents();
+            if (students == null || students.isEmpty()) {
+                log.info("Course {} has no enrolled students", course.getId());
+                continue;
+            }
+
+            // Dispatch email sends to the dedicated executor
+            CompletableFuture<?>[] futures = students.stream()
+                    .map(student -> CompletableFuture.runAsync(() -> {
+                        try {
+                            emailService.sendCourseStartingTomorrowNotification(student, course);
+                        } catch (Exception ex) {
+                            log.error("Failed to send notification to student {} for course {}: {}",
+                                    student.getId(), course.getId(), ex.getMessage(), ex);
+                        }
+                    }, notificationExecutor))
+                    .toArray(CompletableFuture[]::new);
+
+            // Wait for them to complete for this course (optional)
+            try {
+                CompletableFuture.allOf(futures).join();
+            } catch (Exception e) {
+                log.warn("Exception waiting for notification tasks completion for course {}: {}", course.getId(), e.getMessage());
+            }
+        }
+
+        log.info("Notification job finished for courses starting on {}", target);
+    }
+}
+
*** End Patch
*** Begin Patch
*** Add File: src/main/resources/templates/course-start.html
+<!DOCTYPE html>
+<html>
+<head>
+  <meta charset="UTF-8" />
+  <title>Course starts tomorrow</title>
+</head>
+<body>
+  <p>Hi [[FIRST_NAME]],</p>
+
+  <p>This is a reminder that the course <strong>[[COURSE_TITLE]]</strong> starts on <strong>[[COURSE_DATE]]</strong>.</p>
+
+  <p>Course description:</p>
+  <p>[[COURSE_DESCRIPTION]]</p>
+
+  <p>See you there,<br/>Learning Management System</p>
+</body>
+</html>
+
*** End Patch
*** Begin Patch
*** Add File: src/test/java/com/example/project/notification/EmailServiceTest.java
+package com.example.project.notification;
+
+import com.example.project.course.model.Course;
+import com.example.project.course.model.CourseSettings;
+import com.example.project.student.model.Student;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.mockito.Mockito;
+import org.springframework.mail.javamail.JavaMailSender;
+
+import jakarta.mail.internet.MimeMessage;
+import java.time.LocalDateTime;
+
+import static org.mockito.Mockito.*;
+
+public class EmailServiceTest {
+
+    private JavaMailSender mailSender;
+    private OutboxRepository outboxRepository;
+    private EmailService emailService;
+
+    @BeforeEach
+    public void setUp() {
+        mailSender = mock(JavaMailSender.class);
+        outboxRepository = mock(OutboxRepository.class);
+        emailService = new EmailService(mailSender, outboxRepository);
+    }
+
+    @Test
+    public void sendCourseStartingTomorrowNotification_sendsEmail_whenMailSucceeds() throws Exception {
+        MimeMessage mm = mock(MimeMessage.class);
+        when(mailSender.createMimeMessage()).thenReturn(mm);
+
+        Student s = Student.builder().id(java.util.UUID.randomUUID()).firstName("Alice").email("alice@example.com").build();
+
+        Course c = new Course();
+        c.setTitle("Test Course");
+        CourseSettings cs = new CourseSettings();
+        cs.setStartDate(LocalDateTime.now().plusDays(1));
+        c.setSettings(cs);
+        c.setDescription("Desc");
+
+        emailService.sendCourseStartingTomorrowNotification(s, c);
+
+        verify(mailSender, times(1)).send(any(MimeMessage.class));
+        verifyNoInteractions(outboxRepository);
+    }
+
+    @Test
+    public void sendCourseStartingTomorrowNotification_savesToOutbox_whenMailThrows() throws Exception {
+        when(mailSender.createMimeMessage()).thenThrow(new RuntimeException("SMTP down"));
+
+        Student s = Student.builder().id(java.util.UUID.randomUUID()).firstName("Bob").email("bob@example.com").build();
+
+        Course c = new Course();
+        c.setTitle("Another Course");
+        CourseSettings cs = new CourseSettings();
+        cs.setStartDate(LocalDateTime.now().plusDays(1));
+        c.setSettings(cs);
+
+        emailService.sendCourseStartingTomorrowNotification(s, c);
+
+        verify(outboxRepository, times(1)).save(any(OutboxMessage.class));
+    }
+}
+
*** End Patch
*** Begin Patch
*** Add File: src/test/java/com/example/project/notification/CourseNotificationSchedulerTest.java
+package com.example.project.notification;
+
+import com.example.project.course.model.Course;
+import com.example.project.course.service.CourseService;
+import com.example.project.student.model.Student;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.springframework.core.task.SyncTaskExecutor;
+
+import java.time.LocalDateTime;
+import java.util.List;
+
+import static org.mockito.Mockito.*;
+
+public class CourseNotificationSchedulerTest {
+
+    private CourseService courseService;
+    private EmailService emailService;
+    private CourseNotificationScheduler scheduler;
+
+    @BeforeEach
+    public void setUp() {
+        courseService = mock(CourseService.class);
+        emailService = mock(EmailService.class);
+        // use synchronous executor for tests
+        scheduler = new CourseNotificationScheduler(courseService, emailService, new SyncTaskExecutor());
+    }
+
+    @Test
+    public void notifyCoursesStartingTomorrow_dispatchesEmails() {
+        Course course = new Course();
+        course.setId(java.util.UUID.randomUUID());
+        course.setTitle("JUnit Course");
+        Student s = Student.builder().id(java.util.UUID.randomUUID()).email("s@example.com").build();
+        course.setStudents(List.of(s));
+
+        when(courseService.findStartingBetween(any(LocalDateTime.class), any(LocalDateTime.class)))
+                .thenReturn(List.of(course));
+
+        scheduler.notifyCoursesStartingTomorrow();
+
+        verify(emailService, times(1)).sendCourseStartingTomorrowNotification(eq(s), eq(course));
+    }
+}
+
*** End Patch
